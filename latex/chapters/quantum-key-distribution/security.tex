\section{Security analysis}

The security analysis proves the security claims of a \gls{qkd} protocol from a set of specified assumptions using information-theoretical arguments.
More formally, a \gls{qkd} protocol is said to be $\epsilon$-secure, according to the universal security definition~\cite[p.~119]{Wolf2021}, if Alice's and Bob's key is
\begin{enumerate}
	\item $\epsilon$-correct,
	\item $\epsilon$-secret, and
	\item $\epsilon$-secure.
\end{enumerate}
A key is $\epsilon$-correct if the probability that Alice's and Bob's key differs is less or equal than $\epsilon$.
The $\epsilon$-secrecy and -security state explicit inequalities for the trace distance between Eve's, Alice's and Bob's quantum systems, see Ref.~\cite[p.~120]{Wolf2021}.
Using these definitions, it can be shown that an $\epsilon_\text{cor}$-correct and $\epsilon_\text{sec}$-secret \gls{qkd} protocol is $\epsilon$-secure with $\epsilon=\epsilon_\text{cor}+\epsilon_\text{sec}$~\cite[p.~122]{Wolf2021}.
Additional requirements on the key generated by the \gls{qkd} protocol are composability and $\epsilon$-robustness.
A \gls{qkd} protocol is $\epsilon$-robust if the probability that the protocol aborts is equal to $\epsilon$.
A \gls{qkd} protocol not satisfying $\epsilon$-robustness might be unpractical when the probability of abortion is greater than the probability of generating a $\varepsilon$-secure key.
Composability states that using an $\epsilon_1$-secure key as input to an $\epsilon_2$-secure system yields a procedure at least $\epsilon^\prime$-secure with $\epsilon^\prime=\epsilon_1+\epsilon_2$~\cite[p.~10]{Scarani2009}.

We initially stated that the security claims of a \gls{qkd} protocol are derived from a set of assumptions as part of the security proof.
The fundamental assumptions every \gls{qkd} protocol assumes are that
\begin{enumerate}
	\item the quantum theory is correct and complete, and that
	\item authenticated communication is possible,
\end{enumerate}
see, e.g., Ref.~\cite[p.~124]{Wolf2021} and Ref.~\cite[p.~10]{Scarani2009}.
Most security proofs assume an ideal implementation.
However, practical implementations are troubled by imperfections opening up a plethora of attack vectors, see, for instance, Ref.~\cite[p.~8]{Lo2014} for a discussion of hardware imperfections.
Potential loopholes are also present in the software, for instance, the implementation of the authentication protocol or the post-processing.
For a in-depth security analysis of the post-processing, see Ref.~\cite{Fung2010}.
For a proof of privacy amplification in the \gls{qkd} context, see Ref.~\cite{Renner2005}.

While initial security proofs were based on the uncertainty principle, more recent proofs utilize a technique known as entanglement distillation.
While the first security proofs were based on the uncertainty principle, more recent proofs utilize a technique known as entanglement distillation which Shor and Preskill first employed in their simple security proof of BB84~\cite{Shor2000}.

% further reads (practical security considerations and security proofs for CV-QKD and post-processing)
%  and Ref.~\cite{Laudenbach2018}

For a security analysis particular to \gls{cvqkd}, see Ref.~\cite{Diamanti2015}.

